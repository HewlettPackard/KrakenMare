#!/bin/bash

#set -o nounset \
#    -o errexit \
#    -o verbose \
#    -o xtrace

TOOL_NAME=`basename $0`

TOOL_HOME=`dirname $0`

KM_SECRETS_PATH=km-secrets

force_regen=false
check_files=false
check_swarm=false
push_to_swarm=false
delete_pushed=false

#Usage function
usage () {
    
     echo ""
     echo "usage : ${TOOL_NAME} [-h] "
     echo ""
     echo "-w: check secret exist in swarm "
     echo ""
     echo "    exits 2 if 'docker secret ls' does not work"
     echo "    exits 1 if at least one secret is missing"
     echo "    exits 0 if secrets are properly setup"
     echo ""
     echo "-c: check secret files exist (exits 1 if at least one secret is missing)"
     echo "-g: create secret files (erase existing if any, exits 0 if all files could be created)"
     echo "-p: push to swarm (exits 1 if at least one secret could not be pushed)"
     echo "-s: specify secrets path (use $KM_SECRETS_PATH if not specified)"
     echo "-d: goes with -p, delete secret files so that they are only in swarm"
     echo ""
}

secrets_path=~/$KM_SECRETS_PATH

#Parse args
while getopts "hwcgdps:" Option
do
     case $Option in
         h     ) usage $0 ; exit 0        ;;
         w     ) check_swarm=true   ;;
	 c     ) check_files=true   ;;
	 g     ) force_regen=true   ;;
         p     ) push_to_swarm=true ;;
	 d     )
	     if [ "$push_to_swarm" == false ] ; then
		 echo "-d requires -p" >&2 ;
		 exit 1
	     fi
	     delete_pushed=true;
	     ;;
	 s     ) secrets_path=$OPTARG ;;
         *     ) echo "unrecognized option, try $0 -h" >&2 ; usage $0 ; exit 1  ;;
     esac
done


function check_swarm ()
{
    docker secret ls &> /dev/null || return 2
    
    for file in $file_list
    do
	echo "checking secret: $file..."
	docker secret ls | grep -qw $file
	if [ ! "$?" -eq 0 ] ; then
	    echo "" >&2
	    echo "ERROR: missing at least $file" >&2
	    return 1
	fi
    done
    return 0
}

function check_files()
{
    if [ ! -d $secrets_path ] ; then
	echo "" >&2
	echo "ERROR: missing secrets directory $secrets_path" >&2
	echo "run $TOOL_NAME -f or specify alternate path -s" >&2
        return 1
    fi
    
    for file in $file_list
    do
	echo "checking secret: $file..."
	if [ ! -f "$secrets_path/$file" ] ; then
	    echo "" >&2
	    echo "ERROR: missing at least $secrets_path/$file" >&2

	    return 1
	fi
    done
    return 0
}

function gen_secrets ()
{
    if [ ! -d "$secrets_path" ] ; then
	mkdir -p $secrets_path || return 1
    fi
    cp ${TOOL_HOME}/certs-create.sh $secrets_path || return 1
    docker run --rm -v ${secrets_path}:/tmp/ -i openjdk:11-jdk /tmp/certs-create.sh || return 1
    #two extra secrets file are not generated by the command above
    cp ${TOOL_HOME}/broker_jaas.conf $secrets_path || return 1
    cp ${TOOL_HOME}/zookeeper_jaas.conf $secrets_path || return 1
    return 0
}

function push_to_swarm ()
{
    for file in $file_list
    do
	docker secret rm $file 
	docker secret create $file $secrets_path/$file || return 1
	if [ "$delete_pushed" == "true" ] ; then
	    rm $secrets_path/$file || return 1
	fi
    done
    
    return 0
}

#list of secrets
file_list="km-ca-1.key km-ca-1.crt km-ca-1.srl broker_jaas.conf zookeeper_jaas.conf"
for i in broker-1 broker-2 broker-3 schemaregistry connect client
do
    file_list="$file_list ${i}_sslkey_creds"
    file_list="$file_list ${i}_keystore_creds"
    file_list="$file_list ${i}_truststore_creds"
    file_list="$file_list kafka.${i}.keystore.pfx"
    file_list="$file_list kafka.${i}.truststore.pfx"
    file_list="$file_list ${i}-ca1-signed.crt"
    file_list="$file_list ${i}.keystore.p12"
    file_list="$file_list ${i}.key"
    file_list="$file_list ${i}.certificate.pem"
    file_list="$file_list ${i}.der"
    file_list="$file_list ${i}.csr"
done


#full-monty, check swarm and or files and or generate newones and push them...

if  [ "$check_swarm"   == "true" ] && [ "$check_files"   == "true" ] && [ "$push_to_swarm" == "true" ] && [ "$force_regen"   == "true" ] ; then
    #secrets exist in swarm ? exit 0
    check_swarm ; r=$?
    if [ "$r" == 2 ] ; then exit 2 ; fi
    if [ "$r" == 0 ] ; then exit 0 ; fi
    #secret not in swarm, either check they exist as files or generate new ones.
    check_files || gen_secrets || exit 1
    #push to swarm new ones
    push_to_swarm || exit 1
    exit 0
    
fi

#use-case to generate a new keyset as files unless it exists
if [ "$check_files" == "true" ] && [ "$force_regen" == "true" ] ; then
    check_files || gen_secrets || exit 1
    exit 0
fi


#use-case to force a new keyset even if it exist and push to swarm.
if [ "$force_regen" == "true" ] && [ "$push_to_swarm" == "true" ] ; then
    gen_secrets && push_to_swarm || exit 1
    exit 0
fi


#only push to swarm, presuming file are available
if [ "$push_to_swarm" == "true" ] ; then
    check_files || exit 1
    push_to_swarm || exit 1
    exit 0
fi

#only force regen
if [ "$force_regen" == "true" ] ; then
    gen_secrets || exit 1
    exit 0
fi

#only check swarm secrets are there
if [ "$check_swarm" == "true" ]; then
    check_swarm || exit 1
    exit 0
fi

#only check secrets exist as files
if [ "$check_files" == "true" ]; then
    check_files || exit 1
    exit 0
fi

exit 0
